package graphing;

import layout.GraphPane;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

/**
 * Created by Johnny on 2/4/2016.
 */
public class GraphingEngine implements WaveListener, GraphOptionListener
{
    /** List of the the wave objects where index is the tab it is on in the ui.
     * If  a wave/tab is removed in the ui the corresponding wav element should be
     * removed from the list
    */
    private ArrayList<Wave> waves;

//    /** Holds all the wave data generated by the wave objects held in the waves ArrayList.
//     * Like the waves arrayList, the first index corresponds to the first wave / tab in the UI.
//     * The inner index will be pulled from the timeToIndex map that will map each time value to a
//     * unique index.
//     */
//    private ArrayList<ArrayList<GraphPoint[]>> waveData;

    private ArrayList<HashMap<Double, GraphPoint[]>> waveData;

    private double xMin = -5;
    private double xMax = 5;

    private int numPoints = 100;

    /**
     * holds the graphs panel objects which will be requesting data from the engine
     * This will be used to repaint them all when an wave event occurs;
     */
    ArrayList<GraphPane> panes;

    /**
     * Creates a new graphing engine object with an initially empty set of waves and given initial values
     *
     * @param xMin the minimum x value used when generating graph data
     * @param xMax the maximum x value used when generating graph data
     * @param numPoints  the number of points used when generating graph data
     */
    public GraphingEngine(GraphPane pane, double xMin, double xMax, int numPoints)
    {
        this(null, pane, xMin, xMax, numPoints);
    }

    /**
     * Creates a new graphing engine object with an initially empty set of waves and given initial values
     *
     * @param waves a initial set of waves that the graphing engine will use.
     *              If null is passed, an empty set of waves will used.
     * @param pane graphs pane which will be pulling data from the engine
     * @param xMin the minimum x value used when generating graph data
     * @param xMax the maximum x value used when generating graph data
     * @param numPoints  the number of points used when generating graph data
     */
    public GraphingEngine(ArrayList<Wave> waves, GraphPane pane, double xMin, double xMax, int numPoints)
    {
        if(waves == null)
            this.waves = new ArrayList<Wave>(1); //initial set to 1 b/c every viewer will have at at least one wave
        else
            this.waves = waves;

        waveData = new ArrayList<HashMap<Double, GraphPoint[]>>();

        this.xMin = xMin;
        this.xMax = xMax;
        this.numPoints = numPoints;

        panes = new ArrayList<GraphPane>();
        panes.add(pane);
    }

    /**
     * Gets the wave data for a single wave at a single point in time.
     * If the data has not been computed yet, the engine will generate it
     *
     * @param time the time value for the data
     * @param waveID the wave id of the wave whos data is being pulled
     *
     * @return an array of GraphPoints corresponding to that requested wave at the requested time.
     */
    public GraphPoint[] getWaveData(double time, int waveID)
    {
        if(waveData.get(waveID).containsKey(time))
        {
            System.out.println(waveData.size());
            System.out.println(waveData.get(waveID).size());
            return waveData.get(waveID).get(time);
        }
        else
        {
            //generate this data for all waves since its very likely this will be called
            //on the other wave very soon since this call is likely from the ui to redraw
            generateData(time);
            return waveData.get(waveID).get(time);
        }
    }

    /**
     * This method will generate data for all the waves for a given time.
     *
     * @param time the time input used to generate the wave data.
     */
    public void generateData(double time)
    {
        //At some point it could be beneficial to have a thread for each wave generating data.
        for(int i = 0; i < waves.size(); i++)
        {
            GraphPoint[] newPoints = waves.get(i).GeneratePoints(time);
            waveData.get(i).put(time, newPoints);
        }
    }

    /**
     * Adds a graphs panel to the list of panels
     *
     * @param pane the panel to be added
     */
    public void addGraphPane(GraphPane pane)
    {
        this.panes.add(pane);
    }


    /**
     * Sets the graphing engines xMin value.
     * Note - This will cause the system to dump
     * all its currently stored data as that data depends on
     * the xMin staying the same. This is of course
     * sometimes necessary, but should be avoided if possible.
     *
     * @param xMin - the new xMin
     */
    public void setXMin(double xMin)
    {
        this.xMin = xMin;

        clearWaveData();
        updateWaveXValues();
    }

    /**
     * Sets the graphing engines xMax value.
     * Note - This will cause the system to dump
     * all its currently stored data as that data depends on
     * the xMax staying the same. This is of course
     * sometimes necessary, but should be avoided if possible.
     *
     * @param xMax - the new xMax
     */
    public void setXMax(double xMax)
    {
        this.xMax = xMax;

        clearWaveData();
        updateWaveXValues();
    }

    /**
     * Sets the graphing engine's numPoints value.
     * Note - This will cause the system to dump
     * all its currently stored data as that data depends on
     * the the number of points staying the same. This is of course
     * sometimes necessary, but should be avoided if possible.
     *
     * @param numPoints - the new xMax
     */
    public void setNumPoints(int numPoints)
    {
        this.numPoints = numPoints;

        clearWaveData();
        updateWaveXValues();
    }

    /**
     * This method updates all the waves' number of points
     */
    private void updateWaveNumPoints()
    {
        for(Wave w : waves)
        {
            w.setDataPoints(new GraphPoint[numPoints]);
        }

        //have the panels repaint so the change is visible
        for(GraphPane gp : panes)
        {
            gp.repaint();
        }
    }

    /**
     * This method updates all the waves' x values
     */
    private void updateWaveXValues()
    {
        for(Wave w : waves)
        {
            w.setxStart(xMin);
            w.setxEnd(xMax);
        }

        //have the panels repaint so the change is visible
        for(GraphPane gp : panes)
        {
            gp.repaint();
        }
    }

    /**
     * This method clears all the saved wave data. This
     * this is used when x min or max is changed and
     * all the data needs to be recomputed
     */
    private void clearWaveData()
    {
        waveData = new ArrayList<HashMap<Double, GraphPoint[]>>();
        while(waveData.size() <= waves.size())
        {
            waveData.add(new HashMap<Double, GraphPoint[]>());
        }
    }

    @Override
    public void waveUpdated(WaveEvent e)
    {
        if(e.getType() == WaveEvent.EventType.WAVE_ADD)
        {
            waves.add(new Wave(xMin, xMax, numPoints, e.getSettings()));
        }
        else if(e.getType() == WaveEvent.EventType.WAVE_UPDATE)
        {
            while(waves.size() <= e.getWaveID())
            {
              //  waves.add(new Wave(0, 0, 0, null));
                waves.add(null);
                waveData.add(new HashMap<Double, GraphPoint[]>());
            }
            //update the wave

            waves.set(e.getWaveID(), new Wave(xMin, xMax, numPoints, e.getSettings()));

            //clear the data from the previous version of the wave
            waveData.set(e.getWaveID(), new HashMap<Double, GraphPoint[]>());
        }
        else if (e.getType() == WaveEvent.EventType.WAVE_RESET)
        {
            while(waves.size() <= e.getWaveID())
            {
               // waves.add(new Wave(0, 0, 0, null));
                waves.add(null);
                waveData.add(new HashMap<Double, GraphPoint[]>());
            }

            //update the wave
            waves.set(e.getWaveID(), new Wave(xMin, xMax, numPoints, e.getSettings()));

            //clear the data from the previous version of the wave
            waveData.set(e.getWaveID(), new HashMap<Double, GraphPoint[]>());
        }

        //tell all the GraphPanes that use this to repaint, so the event effects are visible
        for(GraphPane pane: panes)
        {
            pane.repaint();
        }
    }

    @Override
    public void GraphOptionUpdate(GraphOptionEvent e)
    {

        System.out.println("Got update event");
        if(e.getNewXMin() != xMin || e.getNewXMax() != xMax)
        {
            setXMin(e.getNewXMin());
            setXMax(e.getNewXMax());
        }

        //we don't care too much about the y value because it is the dependent variable and doesn't effect graphing,
        //but since we have the info from the event object we will update the graph panel
        for(GraphPane gp : panes)
        {
            gp.setyMin(e.getNewYMin());
            gp.setyMax(e.getNewYMax());

            gp.repaint();
        }



    }

    public ArrayList<Wave> getWaves() {
        return waves;
    }

    public ArrayList<HashMap<Double, GraphPoint[]>> getWaveData() {
        return waveData;
    }

    public double getxMin() {
        return xMin;
    }

    public double getxMax() {
        return xMax;
    }
}
